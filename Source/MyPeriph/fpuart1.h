// Последовательный порт с возможностью:
// - получать данные по одному байту функцией getbyteFPUx, с внутренним буфером
// - получать флаг ошибки приема (сбрасывается при чтении) функцией geterrFPUx
// - отправлять пакет данных функцией sendpkgFPUx, пакет должен сохраняться до окончания передачи
// - узнавать статус передачи функцией getsendstateFPUx - пока пакет не передан, буфер должен сохраняться
//   и функция sendpkgFPUx не должна вызываться
// Использует:
//   - Каналы DMA на чтение и на запись

// Версия 0.3
//   - Требует определений myEnterCritical и myExitCritical
//   - Прерывания от используемого таймера должны иметь высокий приоритет
// Версия 0.2 - отличия от версии без номера:
//   - не управляет потоком если не определена соответствующая ножка
//   - время передачи одного байта возвращается функцией get1ByteTimeFPUx

#ifndef FPUART1_H
#define FPUART1_H

#include "mainconfig.h"

// Конфигурация оборудования
#include "fpu1h_conf.h"

// Эту функцию нужно вызывать в процедуре прерывния от таймера FPUxH_TIMER
void FPU1H_TimerInterrupt(void);

// Инициализация или переинициализация
// speed - скорость в бодах
// parity - четность, 0-N, 1-O, 2-E
// rdp - число бит для фиксации окончания приема пакета
uint32_t InitFPU1(uint32_t speed,uint8_t parity);
uint8_t gettoFPU1(void);     // Возвращает 1 если прошло более заданного числа байтов 
uint8_t numbyteFPU1(void);   // Возвращает количество байт в буфере приема
uint8_t getbyteFPU1(void);   // Получает байт. Если байта нет - возвращает 0
uint8_t geterrFPU1(void);    // Возвращает 0 если ошибок нет
void sendpkgFPU1(uint8_t * buf,uint16_t length);  // Инициирует передачу пакета
uint8_t getsendstateFPU1(void);  // Возвращает 0 если передача не производится
uint32_t get1ByteTimeFPU1(void); // Возвращает время передачи 1 байта

#endif
